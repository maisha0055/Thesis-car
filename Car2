// Motor control pins
#define LEFT_FORWARD 9
#define LEFT_REVERSE 10
#define RIGHT_FORWARD 11
#define RIGHT_REVERSE 12

// Speed encoder pins (only using pins 2 and 3 - Arduino Uno's interrupt pins)
#define ENCODER_LEFT 2   // Left side encoder
#define ENCODER_RIGHT 3  // Right side encoder

// Variables for Bluetooth control
char t;

// Variables for speed measurement
unsigned int rpmLeft, rpmRight;
volatile byte pulsesLeft, pulsesRight;
unsigned long TIME;
unsigned int pulse_per_turn = 20; // Adjust based on your encoder disc slots

// Interrupt service routines for counting encoder pulses
void countLeft() {
  pulsesLeft++;
}

void countRight() {
  pulsesRight++;
}

void setup() {
  // Motor pins setup
  pinMode(LEFT_FORWARD, OUTPUT);
  pinMode(LEFT_REVERSE, OUTPUT);
  pinMode(RIGHT_FORWARD, OUTPUT);
  pinMode(RIGHT_REVERSE, OUTPUT);
  
  // Speed encoder pins setup
  pinMode(ENCODER_LEFT, INPUT);
  pinMode(ENCODER_RIGHT, INPUT);
  
  // Initialize variables
  rpmLeft = rpmRight = 0;
  pulsesLeft = pulsesRight = 0;
  TIME = 0;
  
  // Serial communication for Bluetooth
  Serial.begin(9600);
  
  // Attach interrupts for speed encoders
  attachInterrupt(digitalPinToInterrupt(ENCODER_LEFT), countLeft, FALLING);
  attachInterrupt(digitalPinToInterrupt(ENCODER_RIGHT), countRight, FALLING);
  
  Serial.println("Car initialized!");
}

void loop() {
  // Handle Bluetooth commands
  if (Serial.available()) {
    t = Serial.read();
    Serial.print("Command received: ");
    Serial.println(t);
  }
  
  // Motor control based on Bluetooth command
  if (t == '1') {  // Move forward
    digitalWrite(LEFT_FORWARD, HIGH);
    digitalWrite(LEFT_REVERSE, LOW);
    digitalWrite(RIGHT_FORWARD, HIGH);
    digitalWrite(RIGHT_REVERSE, LOW);
  }
  else if (t == '2') {  // Move reverse/backward
    digitalWrite(LEFT_FORWARD, LOW);
    digitalWrite(LEFT_REVERSE, HIGH);
    digitalWrite(RIGHT_FORWARD, LOW);
    digitalWrite(RIGHT_REVERSE, HIGH);
  }
  else if (t == '3') {  // Turn right
    digitalWrite(LEFT_FORWARD, HIGH);
    digitalWrite(LEFT_REVERSE, LOW);
    digitalWrite(RIGHT_FORWARD, LOW);
    digitalWrite(RIGHT_REVERSE, LOW);
  }
  else if (t == '4') {  // Turn left
    digitalWrite(LEFT_FORWARD, LOW);
    digitalWrite(LEFT_REVERSE, LOW);
    digitalWrite(RIGHT_FORWARD, HIGH);
    digitalWrite(RIGHT_REVERSE, LOW);
  }
  else if (t == '5') {  // Stop
    digitalWrite(LEFT_FORWARD, LOW);
    digitalWrite(LEFT_REVERSE, LOW);
    digitalWrite(RIGHT_FORWARD, LOW);
    digitalWrite(RIGHT_REVERSE, LOW);
  }
  
  // Speed measurement (updates every 100ms)
  if (millis() - TIME >= 100) {
    // Detach interrupts temporarily
    detachInterrupt(digitalPinToInterrupt(ENCODER_LEFT));
    detachInterrupt(digitalPinToInterrupt(ENCODER_RIGHT));
    
    unsigned long timeDiff = millis() - TIME;
    
    // Calculate RPM for both encoders
    rpmLeft = (60 * 100 / pulse_per_turn) / timeDiff * pulsesLeft;
    rpmRight = (60 * 100 / pulse_per_turn) / timeDiff * pulsesRight;
    
    TIME = millis();
    
    // Reset pulse counters
    pulsesLeft = pulsesRight = 0;
    
    // Print RPM to Serial
    Serial.print("Left RPM: ");
    Serial.print(rpmLeft);
    Serial.print(" | Right RPM: ");
    Serial.println(rpmRight);
    
    // Re-attach interrupts
    attachInterrupt(digitalPinToInterrupt(ENCODER_LEFT), countLeft, FALLING);
    attachInterrupt(digitalPinToInterrupt(ENCODER_RIGHT), countRight, FALLING);
  }
  
  delay(100);
}
